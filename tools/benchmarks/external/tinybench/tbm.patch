--- util.c
+++ util_patch.c
@@ -1,3 +1,28 @@
+/* Copyright (C) 2023-25 Advanced Micro Devices, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
 /*
  * Copyright © 2011 Siarhei Siamashka <siarhei.siamashka@gmail.com>
  *
@@ -316,48 +341,74 @@
     return (char *)(((uintptr_t)ptr + align - 1) & ~(uintptr_t)(align - 1));
 }
 
-void *alloc_four_nonaliased_buffers(void **buf1_, int size1,
-                                    void **buf2_, int size2,
-                                    void **buf3_, int size3,
-                                    void **buf4_, int size4)
+void *alloc_four_nonaliased_buffers(void **buf1_, size_t size1,
+                                    void **buf2_, size_t size2,
+                                    void **buf3_, size_t size3,
+                                    void **buf4_, size_t size4)
 {
     char **buf1 = (char **)buf1_, **buf2 = (char **)buf2_;
     char **buf3 = (char **)buf3_, **buf4 = (char **)buf4_;
-    int antialias_pattern_mask = (ALIGN_PADDING - 1) & ~(CACHE_LINE_SIZE - 1);
-    char *buf, *ptr;
-
-    if (!buf1 || size1 < 0)
-        size1 = 0;
-    if (!buf2 || size2 < 0)
-        size2 = 0;
-    if (!buf3 || size3 < 0)
-        size3 = 0;
-    if (!buf4 || size4 < 0)
-        size4 = 0;
-
-    ptr = buf = 
-        (char *)malloc(size1 + size2 + size3 + size4 + 9 * ALIGN_PADDING);
-    memset(buf, 0xCC, size1 + size2 + size3 + size4 + 9 * ALIGN_PADDING);
+    size_t antialias_pattern_mask = (ALIGN_PADDING - 1) & ~(CACHE_LINE_SIZE - 1);
+    char *buf = NULL, *ptr = NULL;
+    size_t total_size;
+
+    // Validate input sizes
+    if (!buf1 || size1 == 0) size1 = 0;
+    if (!buf2 || size2 == 0) size2 = 0;
+    if (!buf3 || size3 == 0) size3 = 0;
+    if (!buf4 || size4 == 0) size4 = 0;
+
+    // Check for overflow in total size calculation
+    if (size1 > SIZE_MAX - (9 * ALIGN_PADDING) ||
+    size2 > SIZE_MAX - (size1 + 9 * ALIGN_PADDING) ||
+    size3 > SIZE_MAX - (size1 + size2 + 9 * ALIGN_PADDING) ||
+    size4 > SIZE_MAX - (size1 + size2 + size3 + 9 * ALIGN_PADDING)) {
+    return NULL;
+    }
+    total_size = size1 + size2 + size3 + size4 + 9 * ALIGN_PADDING;
+
+    // Allocate memory with error checking
+    buf = (char *)malloc(total_size);
+    if (!buf) {
+        return NULL;
+    }
+    // Initialize memory
+    memset(buf, 0xCC, total_size);
+    ptr = align_up(buf, ALIGN_PADDING);
 
-    ptr = align_up(ptr, ALIGN_PADDING);
-    if (buf1)
-    {
+    // Assign buffers with overflow checks
+    if (buf1) {
         *buf1 = ptr + (0xAAAAAAAA & antialias_pattern_mask);
         ptr = align_up(*buf1 + size1, ALIGN_PADDING);
+        if (ptr < *buf1) { // Check for overflow
+            free(buf);
+            return NULL;
+        }
     }
-    if (buf2)
-    {
+    if (buf2) {
         *buf2 = ptr + (0x55555555 & antialias_pattern_mask);
         ptr = align_up(*buf2 + size2, ALIGN_PADDING);
+        if (ptr < *buf2) {
+            free(buf);
+            return NULL;
+        }
     }
-    if (buf3)
-    {
+
+    if (buf3) {
         *buf3 = ptr + (0xCCCCCCCC & antialias_pattern_mask);
         ptr = align_up(*buf3 + size3, ALIGN_PADDING);
+        if (ptr < *buf3) {
+            free(buf);
+            return NULL;
+        }
     }
-    if (buf4)
-    {
+
+    if (buf4) {
         *buf4 = ptr + (0x33333333 & antialias_pattern_mask);
+        if (*buf4 < ptr) { // Check for overflow
+            free(buf);
+            return NULL;
+        }
     }
 
     return buf;
--- util.h
+++ util_patch.h
@@ -1,3 +1,28 @@
+/* Copyright (C) 2023-25 Advanced Micro Devices, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
 /*
  * Copyright © 2011 Siarhei Siamashka <siarhei.siamashka@gmail.com>
  *
@@ -63,9 +88,9 @@
                                   int64_t * __restrict src,
                                   int                  size);
 
-void *alloc_four_nonaliased_buffers(void **buf1, int size1,
-                                    void **buf2, int size2,
-                                    void **buf3, int size3,
-                                    void **buf4, int size4);
+void *alloc_four_nonaliased_buffers(void **buf1, size_t size1,
+                                    void **buf2, size_t size2,
+                                    void **buf3, size_t size3,
+                                    void **buf4, size_t size4);
 
 #endif
--- main.c
+++ main_patch.c
@@ -1,3 +1,28 @@
+/* Copyright (C) 2023-25 Advanced Micro Devices, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
 /*
  * Copyright © 2011 Siarhei Siamashka <siarhei.siamashka@gmail.com>
  *
@@ -21,6 +46,8 @@
  * DEALINGS IN THE SOFTWARE.
  */

+// Enable GNU extensions to declare mempcpy() and other non-standard functions.
+#define _GNU_SOURCE
 #include <string.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -28,73 +55,70 @@
 #include <math.h>
 #include <sys/time.h>
 
-#ifdef __linux__
 #include <unistd.h>
 #include <fcntl.h>
 #include <linux/fb.h>
 #include <sys/mman.h>
 #include <sys/ioctl.h>
-#endif
+
 
 #include "util.h"
-#include "asm-opt.h"
 #include "version.h"
-
-#define SIZE             (32 * 1024 * 1024)
-#define BLOCKSIZE        2048
+#define BLOCKSIZE               2048
 #ifndef MAXREPEATS
-# define MAXREPEATS      10
+# define MAXREPEATS             10
 #endif
-#ifndef LATBENCH_COUNT
-# define LATBENCH_COUNT  10000000
+# define NULL_BYTE              1
+#define MIN_PRINTABLE_ASCII     32
+#define MAX_PRINTABLE_ASCII     127
+#define NULL_TERM_CHAR          '\0'
+#ifndef __ASM_OPT_H__
+#define __ASM_OPT_H__
+typedef struct
+{
+    const char *description;
+    int use_tmpbuf;
+    int (*f)(int64_t *, int64_t *, size_t);
+} bench_info;
+bench_info *get_asm_benchmarks(void);
+bench_info *get_asm_framebuffer_benchmarks(void);
 #endif
-
-#ifdef __linux__
 static void *mmap_framebuffer(size_t *fbsize)
 {
     int fd;
     void *p;
     struct fb_fix_screeninfo finfo;
-
     if ((fd = open("/dev/fb0", O_RDWR)) == -1)
         if ((fd = open("/dev/graphics/fb0", O_RDWR)) == -1)
             return NULL;
-
     if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo)) {
         close(fd);
         return NULL;
     }
-
     p = mmap(0, finfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
     close(fd);
-
     if (p == (void *)-1)
         return NULL;
-
     *fbsize = finfo.smem_len;
     return p;
 }
-#endif
-
 static double bandwidth_bench_helper(int64_t *dstbuf, int64_t *srcbuf,
                                      int64_t *tmpbuf,
                                      int size, int blocksize,
                                      const char *indent_prefix,
                                      int use_tmpbuf,
-                                     void (*f)(int64_t *, int64_t *, int),
+                                     int (*f)(int64_t *, int64_t *, size_t),
                                      const char *description)
 {
     int i, j, loopcount, innerloopcount, n;
     double t1, t2;
     double speed, maxspeed;
     double s, s0, s1, s2;
-
     /* do up to MAXREPEATS measurements */
     s = s0 = s1 = s2 = 0;
     maxspeed   = 0;
     for (n = 0; n < MAXREPEATS; n++)
     {
-        f(dstbuf, srcbuf, size);
         loopcount = 0;
         innerloopcount = 1;
         t1 = gettime();
@@ -114,23 +138,30 @@
             }
             else
             {
-                for (i = 0; i < innerloopcount; i++)
+               if(strstr(description,"cat") == NULL)
+                {   for (i = 0; i < innerloopcount; i++)
+                    {
+                        (void)f(dstbuf, srcbuf, size);
+                    }
+                }
+                else
                 {
-                    f(dstbuf, srcbuf, size);
+                    for (i = 0; i < innerloopcount; i++)
+                    {
+                        *(dstbuf + size - 1) = '\0';
+                        f(dstbuf, srcbuf, size);
+                    }
                 }
             }
             innerloopcount *= 2;
             t2 = gettime();
         } while (t2 - t1 < 0.5);
         speed = (double)size * loopcount / (t2 - t1) / 1000000.;
-
         s0 += 1;
         s1 += speed;
         s2 += speed * speed;
-
         if (speed > maxspeed)
             maxspeed = speed;
-
         if (s0 > 2)
         {
             s = sqrt((s0 * s2 - s1 * s1) / (s0 * (s0 - 1)));
@@ -138,7 +169,6 @@
                 break;
         }
     }
-
     if (maxspeed > 0 && s / maxspeed * 100. >= 0.1)
     {
         printf("%s%-52s : %8.1f MB/s (%.1f%%)\n", indent_prefix, description,
@@ -150,42 +180,70 @@
     }
     return maxspeed;
 }
-
-void memcpy_wrapper(int64_t *dst, int64_t *src, int size)
+int memcpy_wrapper(int64_t *dst, int64_t *src, size_t size)
 {
     memcpy(dst, src, size);
 }
-
-void memset_wrapper(int64_t *dst, int64_t *src, int size)
+int memset_wrapper(int64_t *dst, int64_t *src, size_t size)
 {
     memset(dst, src[0], size);
 }
-
-static bench_info c_benchmarks[] =
+int memmove_wrapper(int64_t *dst, int64_t *src, size_t size)
 {
-    { "C copy backwards", 0, aligned_block_copy_backwards },
-    { "C copy backwards (32 byte blocks)", 0, aligned_block_copy_backwards_bs32 },
-    { "C copy backwards (64 byte blocks)", 0, aligned_block_copy_backwards_bs64 },
-    { "C copy", 0, aligned_block_copy },
-    { "C copy prefetched (32 bytes step)", 0, aligned_block_copy_pf32 },
-    { "C copy prefetched (64 bytes step)", 0, aligned_block_copy_pf64 },
-    { "C 2-pass copy", 1, aligned_block_copy },
-    { "C 2-pass copy prefetched (32 bytes step)", 1, aligned_block_copy_pf32 },
-    { "C 2-pass copy prefetched (64 bytes step)", 1, aligned_block_copy_pf64 },
-    { "C fill", 0, aligned_block_fill },
-    { "C fill (shuffle within 16 byte blocks)", 0, aligned_block_fill_shuffle16 },
-    { "C fill (shuffle within 32 byte blocks)", 0, aligned_block_fill_shuffle32 },
-    { "C fill (shuffle within 64 byte blocks)", 0, aligned_block_fill_shuffle64 },
-    { NULL, 0, NULL }
-};
-
-static bench_info libc_benchmarks[] =
+    memmove(dst, src, size);
+}
+int memcmp_wrapper(int64_t *dst, int64_t *src, size_t size)
 {
-    { "standard memcpy", 0, memcpy_wrapper },
-    { "standard memset", 0, memset_wrapper },
-    { NULL, 0, NULL }
-};
-
+    return memcmp(dst, src, size);
+}
+int mempcpy_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    mempcpy(dst, src, size);
+}
+int strcpy_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    strcpy((char *)dst, (char *) src);
+}
+int strncpy_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    strncpy((char *)dst, (char *) src, size);
+}
+int strcmp_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    return strcmp((char *)dst, (char *) src);
+}
+int strncmp_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    return strncmp((char *)dst, (char *) src, size);
+}
+int strlen_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    return strlen((char *)src);
+}
+int strcat_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    strcat((char *)dst, (char *)src);
+}
+int strncat_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    strncat((char *)dst, (char *)src, size);
+}
+int strspn_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    strspn((char *)dst, (char *)src);
+}
+int strstr_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    return strstr((char *)dst, (char *)src);
+}
+int memchr_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    return memchr(src, 'x' , size);
+}
+int strchr_wrapper(int64_t *dst, int64_t *src, size_t size)
+{
+    return strchr((char *)src,'!');
+}
 void bandwidth_bench(int64_t *dstbuf, int64_t *srcbuf, int64_t *tmpbuf,
                      int size, int blocksize, const char *indent_prefix,
                      bench_info *bi)
@@ -199,391 +257,110 @@
         bi++;
     }
 }
-
-static void __attribute__((noinline)) random_read_test(char *zerobuffer,
-                                                       int count, int nbits)
-{
-    uint32_t seed = 0;
-    uintptr_t addrmask = (1 << nbits) - 1;
-    uint32_t v;
-    static volatile uint32_t dummy;
-
-#ifdef __arm__
-    uint32_t tmp;
-    __asm__ volatile (
-        "subs %[count], %[count],       #16\n"
-        "blt  1f\n"
-    "0:\n"
-        "subs %[count], %[count],       #16\n"
-    ".rept 16\n"
-        "mla  %[seed],  %[c1103515245], %[seed],        %[c12345]\n"
-        "and  %[v],     %[xFF],         %[seed],        lsr #16\n"
-        "mla  %[seed],  %[c1103515245], %[seed],        %[c12345]\n"
-        "and  %[tmp],   %[xFF00],       %[seed],        lsr #8\n"
-        "mla  %[seed],  %[c1103515245], %[seed],        %[c12345]\n"
-        "orr  %[v],     %[v],           %[tmp]\n"
-        "and  %[tmp],   %[x7FFF0000],   %[seed]\n"
-        "orr  %[v],     %[v],           %[tmp]\n"
-        "and  %[v],     %[v],           %[addrmask]\n"
-        "ldrb %[v],     [%[zerobuffer], %[v]]\n"
-        "orr  %[seed],  %[seed],        %[v]\n"
-    ".endr\n"
-        "bge  0b\n"
-    "1:\n"
-        "add  %[count], %[count],       #16\n"
-        : [count] "+&r" (count),
-          [seed] "+&r" (seed), [v] "=&r" (v),
-          [tmp] "=&r" (tmp)
-        : [c1103515245] "r" (1103515245), [c12345] "r" (12345),
-          [xFF00] "r" (0xFF00), [xFF] "r" (0xFF),
-          [x7FFF0000] "r" (0x7FFF0000),
-          [zerobuffer] "r" (zerobuffer),
-          [addrmask] "r" (addrmask)
-        : "cc");
-#else
-    #define RANDOM_MEM_ACCESS()                 \
-        seed = seed * 1103515245 + 12345;       \
-        v = (seed >> 16) & 0xFF;                \
-        seed = seed * 1103515245 + 12345;       \
-        v |= (seed >> 8) & 0xFF00;              \
-        seed = seed * 1103515245 + 12345;       \
-        v |= seed & 0x7FFF0000;                 \
-        seed |= zerobuffer[v & addrmask];
-
-    while (count >= 16) {
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        count -= 16;
-    }
-#endif
-    dummy = seed;
-    #undef RANDOM_MEM_ACCESS
-}
-
-static void __attribute__((noinline)) random_dual_read_test(char *zerobuffer,
-                                                            int count, int nbits)
+bench_info supp_funcs[]=
 {
-    uint32_t seed = 0;
-    uintptr_t addrmask = (1 << nbits) - 1;
-    uint32_t v1, v2;
-    static volatile uint32_t dummy;
-
-#ifdef __arm__
-    uint32_t tmp;
-    __asm__ volatile (
-        "subs %[count], %[count],       #16\n"
-        "blt  1f\n"
-    "0:\n"
-        "subs %[count], %[count],       #16\n"
-    ".rept 16\n"
-        "mla  %[seed],  %[c1103515245], %[seed],        %[c12345]\n"
-        "and  %[v1],    %[xFF00],       %[seed],        lsr #8\n"
-        "mla  %[seed],  %[c1103515245], %[seed],        %[c12345]\n"
-        "and  %[v2],    %[xFF00],       %[seed],        lsr #8\n"
-        "mla  %[seed],  %[c1103515245], %[seed],        %[c12345]\n"
-        "and  %[tmp],   %[x7FFF0000],   %[seed]\n"
-        "mla  %[seed],  %[c1103515245], %[seed],        %[c12345]\n"
-        "orr  %[v1],    %[v1],          %[tmp]\n"
-        "and  %[tmp],   %[x7FFF0000],   %[seed]\n"
-        "mla  %[seed],  %[c1103515245], %[seed],        %[c12345]\n"
-        "orr  %[v2],    %[v2],          %[tmp]\n"
-        "and  %[tmp],   %[xFF],         %[seed],        lsr #16\n"
-        "orr  %[v2],    %[v2],          %[seed],        lsr #24\n"
-        "orr  %[v1],    %[v1],          %[tmp]\n"
-        "and  %[v2],    %[v2],          %[addrmask]\n"
-        "eor  %[v1],    %[v1],          %[v2]\n"
-        "and  %[v1],    %[v1],          %[addrmask]\n"
-        "ldrb %[v2],    [%[zerobuffer], %[v2]]\n"
-        "ldrb %[v1],    [%[zerobuffer], %[v1]]\n"
-        "orr  %[seed],  %[seed],        %[v2]\n"
-        "add  %[seed],  %[seed],        %[v1]\n"
-    ".endr\n"
-        "bge  0b\n"
-    "1:\n"
-        "add  %[count], %[count],       #16\n"
-        : [count] "+&r" (count),
-          [seed] "+&r" (seed), [v1] "=&r" (v1), [v2] "=&r" (v2),
-          [tmp] "=&r" (tmp)
-        : [c1103515245] "r" (1103515245), [c12345] "r" (12345),
-          [xFF00] "r" (0xFF00), [xFF] "r" (0xFF),
-          [x7FFF0000] "r" (0x7FFF0000),
-          [zerobuffer] "r" (zerobuffer),
-          [addrmask] "r" (addrmask)
-        : "cc");
-#else
-    #define RANDOM_MEM_ACCESS()                 \
-        seed = seed * 1103515245 + 12345;       \
-        v1 = (seed >> 8) & 0xFF00;              \
-        seed = seed * 1103515245 + 12345;       \
-        v2 = (seed >> 8) & 0xFF00;              \
-        seed = seed * 1103515245 + 12345;       \
-        v1 |= seed & 0x7FFF0000;                \
-        seed = seed * 1103515245 + 12345;       \
-        v2 |= seed & 0x7FFF0000;                \
-        seed = seed * 1103515245 + 12345;       \
-        v1 |= (seed >> 16) & 0xFF;              \
-        v2 |= (seed >> 24);                     \
-        v2 &= addrmask;                         \
-        v1 ^= v2;                               \
-        seed |= zerobuffer[v2];                 \
-        seed += zerobuffer[v1 & addrmask];
-
-    while (count >= 16) {
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        RANDOM_MEM_ACCESS();
-        count -= 16;
-    }
-#endif
-    dummy = seed;
-    #undef RANDOM_MEM_ACCESS
-}
-
-static uint32_t rand32()
-{
-    static int seed = 0;
-    uint32_t hi, lo;
-    hi = (seed = seed * 1103515245 + 12345) >> 16;
-    lo = (seed = seed * 1103515245 + 12345) >> 16;
-    return (hi << 16) + lo;
-}
-
-int latency_bench(int size, int count, int use_hugepage)
-{
-    double t, t2, t_before, t_after, t_noaccess, t_noaccess2;
-    double xs, xs0, xs1, xs2;
-    double ys, ys0, ys1, ys2;
-    double min_t, min_t2;
-    int nbits, n;
-    char *buffer, *buffer_alloc;
-#if !defined(__linux__) || !defined(MADV_HUGEPAGE)
-    if (use_hugepage)
-        return 0;
-    buffer_alloc = (char *)malloc(size + 4095);
-    if (!buffer_alloc)
-        return 0;
-    buffer = (char *)(((uintptr_t)buffer_alloc + 4095) & ~(uintptr_t)4095);
-#else
-    if (posix_memalign((void **)&buffer_alloc, 4 * 1024 * 1024, size) != 0)
-        return 0;
-    buffer = buffer_alloc;
-    if (use_hugepage && madvise(buffer, size, use_hugepage > 0 ?
-                                MADV_HUGEPAGE : MADV_NOHUGEPAGE) != 0)
-    {
-        free(buffer_alloc);
-        return 0;
-    }
-#endif
-    memset(buffer, 0, size);
-
-    for (n = 1; n <= MAXREPEATS; n++)
-    {
-        t_before = gettime();
-        random_read_test(buffer, count, 1);
-        t_after = gettime();
-        if (n == 1 || t_after - t_before < t_noaccess)
-            t_noaccess = t_after - t_before;
-
-        t_before = gettime();
-        random_dual_read_test(buffer, count, 1);
-        t_after = gettime();
-        if (n == 1 || t_after - t_before < t_noaccess2)
-            t_noaccess2 = t_after - t_before;
-    }
-
-    printf("\nblock size : single random read / dual random read");
-    if (use_hugepage > 0)
-        printf(", [MADV_HUGEPAGE]\n");
-    else if (use_hugepage < 0)
-        printf(", [MADV_NOHUGEPAGE]\n");
-    else
-        printf("\n");
-
-    for (nbits = 10; (1 << nbits) <= size; nbits++)
-    {
-        int testsize = 1 << nbits;
-        xs1 = xs2 = ys = ys1 = ys2 = 0;
-        for (n = 1; n <= MAXREPEATS; n++)
-        {
-            /*
-             * Select a random offset in order to mitigate the unpredictability
-             * of cache associativity effects when dealing with different
-             * physical memory fragmentation (for PIPT caches). We are reporting
-             * the "best" measured latency, some offsets may be better than
-             * the others.
-             */
-            int testoffs = (rand32() % (size / testsize)) * testsize;
-
-            t_before = gettime();
-            random_read_test(buffer + testoffs, count, nbits);
-            t_after = gettime();
-            t = t_after - t_before - t_noaccess;
-            if (t < 0) t = 0;
-
-            xs1 += t;
-            xs2 += t * t;
-
-            if (n == 1 || t < min_t)
-                min_t = t;
-
-            t_before = gettime();
-            random_dual_read_test(buffer + testoffs, count, nbits);
-            t_after = gettime();
-            t2 = t_after - t_before - t_noaccess2;
-            if (t2 < 0) t2 = 0;
-
-            ys1 += t2;
-            ys2 += t2 * t2;
-
-            if (n == 1 || t2 < min_t2)
-                min_t2 = t2;
-
-            if (n > 2)
-            {
-                xs = sqrt((xs2 * n - xs1 * xs1) / (n * (n - 1)));
-                ys = sqrt((ys2 * n - ys1 * ys1) / (n * (n - 1)));
-                if (xs < min_t / 1000. && ys < min_t2 / 1000.)
-                    break;
-            }
-        }
-        printf("%10d : %6.1f ns          /  %6.1f ns \n", (1 << nbits),
-            min_t * 1000000000. / count,  min_t2 * 1000000000. / count);
+    {"memcpy", 0, memcpy_wrapper},
+    {"mempcpy", 0, mempcpy_wrapper},
+    {"memmove", 0, memmove_wrapper},
+    {"memset", 0, memset_wrapper},
+    {"memcmp", 0, memcmp_wrapper},
+    {"memchr", 0, memchr_wrapper},
+    {"strcpy", 0, strcpy_wrapper},
+    {"strncpy", 0, strncpy_wrapper},
+    {"strcmp", 0, strcmp_wrapper},
+    {"strncmp", 0, strncmp_wrapper},
+    {"strlen", 0, strlen_wrapper},
+    {"strcat", 0, strcat_wrapper},
+    {"strncat", 0, strncat_wrapper},
+    {"strspn", 0, strspn_wrapper},
+    {"strstr", 0, strstr_wrapper},
+    {"strchr", 0, strchr_wrapper},
+    {"none", 0,  NULL}
+};
+void generate_uniq_random_string(char * str, size_t length) {
+    size_t i;
+    for (i = 0; i < length ; i++) {
+        str[i] = MIN_PRINTABLE_ASCII + (i % (MAX_PRINTABLE_ASCII - MIN_PRINTABLE_ASCII)) ; // printable ASCII chars from 32 to 126
     }
-    free(buffer_alloc);
-    return 1;
+    str[i] = NULL_TERM_CHAR;
 }
-
-int main(void)
+int main(int argc, char **argv)
 {
-    int latbench_size = SIZE * 2, latbench_count = LATBENCH_COUNT;
+    srand(0);
     int64_t *srcbuf, *dstbuf, *tmpbuf;
     void *poolbuf;
-    size_t bufsize = SIZE;
-#ifdef __linux__
+    size_t start, end, bufsize = 0;
+    unsigned int iter = 0;
+    int idx;
     size_t fbsize = 0;
     int64_t *fbbuf = mmap_framebuffer(&fbsize);
     fbsize = (fbsize / BLOCKSIZE) * BLOCKSIZE;
-#endif
-
-    printf("tinymembench v" VERSION " (simple benchmark for memory throughput and latency)\n");
-
-
-    poolbuf = alloc_four_nonaliased_buffers((void **)&srcbuf, bufsize,
-                                            (void **)&dstbuf, bufsize,
-                                            (void **)&tmpbuf, BLOCKSIZE,
-                                            NULL, 0);
-    printf("\n");
-    printf("==========================================================================\n");
-    printf("== Memory bandwidth tests                                               ==\n");
-    printf("==                                                                      ==\n");
-    printf("== Note 1: 1MB = 1000000 bytes                                          ==\n");
-    printf("== Note 2: Results for 'copy' tests show how many bytes can be          ==\n");
-    printf("==         copied per second (adding together read and writen           ==\n");
-    printf("==         bytes would have provided twice higher numbers)              ==\n");
-    printf("== Note 3: 2-pass copy means that we are using a small temporary buffer ==\n");
-    printf("==         to first fetch data into it, and only then write it to the   ==\n");
-    printf("==         destination (source -> L1 cache, L1 cache -> destination)    ==\n");
-    printf("== Note 4: If sample standard deviation exceeds 0.1%%, it is shown in    ==\n");
-    printf("==         brackets                                                     ==\n");
-    printf("==========================================================================\n\n");
-
-    bandwidth_bench(dstbuf, srcbuf, tmpbuf, bufsize, BLOCKSIZE, " ", c_benchmarks);
-    printf(" ---\n");
-    bandwidth_bench(dstbuf, srcbuf, tmpbuf, bufsize, BLOCKSIZE, " ", libc_benchmarks);
-    bench_info *bi = get_asm_benchmarks();
-    if (bi->f) {
-        printf(" ---\n");
-        bandwidth_bench(dstbuf, srcbuf, tmpbuf, bufsize, BLOCKSIZE, " ", bi);
-    }
-
-#ifdef __linux__
-    bi = get_asm_framebuffer_benchmarks();
-    if (bi->f && fbbuf)
+    static bench_info bench_func[] = {{NULL, 0,  NULL}, {NULL, 0,  NULL}};
+    start = atoi(argv[2]);
+    end = atoi(argv[3]);
+    //iterator choice - 0 stands for shift left by 1
+    iter = atoi(argv[4]);
+    for (idx = 0; idx <= sizeof(supp_funcs)/sizeof(supp_funcs[0]); idx++)
     {
-        printf("\n");
-        printf("==========================================================================\n");
-        printf("== Framebuffer read tests.                                              ==\n");
-        printf("==                                                                      ==\n");
-        printf("== Many ARM devices use a part of the system memory as the framebuffer, ==\n");
-        printf("== typically mapped as uncached but with write-combining enabled.       ==\n");
-        printf("== Writes to such framebuffers are quite fast, but reads are much       ==\n");
-        printf("== slower and very sensitive to the alignment and the selection of      ==\n");
-        printf("== CPU instructions which are used for accessing memory.                ==\n");
-        printf("==                                                                      ==\n");
-        printf("== Many x86 systems allocate the framebuffer in the GPU memory,         ==\n");
-        printf("== accessible for the CPU via a relatively slow PCI-E bus. Moreover,    ==\n");
-        printf("== PCI-E is asymmetric and handles reads a lot worse than writes.       ==\n");
-        printf("==                                                                      ==\n");
-        printf("== If uncached framebuffer reads are reasonably fast (at least 100 MB/s ==\n");
-        printf("== or preferably >300 MB/s), then using the shadow framebuffer layer    ==\n");
-        printf("== is not necessary in Xorg DDX drivers, resulting in a nice overall    ==\n");
-        printf("== performance improvement. For example, the xf86-video-fbturbo DDX     ==\n");
-        printf("== uses this trick.                                                     ==\n");
-        printf("==========================================================================\n\n");
-
-        srcbuf = fbbuf;
-        if (bufsize > fbsize)
-            bufsize = fbsize;
-        bandwidth_bench(dstbuf, srcbuf, tmpbuf, bufsize, BLOCKSIZE, " ", bi);
+        if (!strcmp(supp_funcs[idx].description, argv[1]))
+        {
+           break;
+        }
     }
-#endif
-
-    free(poolbuf);
-
-    printf("\n");
-    printf("==========================================================================\n");
-    printf("== Memory latency test                                                  ==\n");
-    printf("==                                                                      ==\n");
-    printf("== Average time is measured for random memory accesses in the buffers   ==\n");
-    printf("== of different sizes. The larger is the buffer, the more significant   ==\n");
-    printf("== are relative contributions of TLB, L1/L2 cache misses and SDRAM      ==\n");
-    printf("== accesses. For extremely large buffer sizes we are expecting to see   ==\n");
-    printf("== page table walk with several requests to SDRAM for almost every      ==\n");
-    printf("== memory access (though 64MiB is not nearly large enough to experience ==\n");
-    printf("== this effect to its fullest).                                         ==\n");
-    printf("==                                                                      ==\n");
-    printf("== Note 1: All the numbers are representing extra time, which needs to  ==\n");
-    printf("==         be added to L1 cache latency. The cycle timings for L1 cache ==\n");
-    printf("==         latency can be usually found in the processor documentation. ==\n");
-    printf("== Note 2: Dual random read means that we are simultaneously performing ==\n");
-    printf("==         two independent memory accesses at a time. In the case if    ==\n");
-    printf("==         the memory subsystem can't handle multiple outstanding       ==\n");
-    printf("==         requests, dual random read has the same timings as two       ==\n");
-    printf("==         single reads performed one after another.                    ==\n");
-    printf("==========================================================================\n");
-
-    if (!latency_bench(latbench_size, latbench_count, -1) ||
-        !latency_bench(latbench_size, latbench_count, 1))
+    bench_func[0].description = supp_funcs[idx].description;
+    bench_func[0].use_tmpbuf = supp_funcs[idx].use_tmpbuf;
+    bench_func[0].f = supp_funcs[idx].f;
+    for (bufsize = start; bufsize<= end; bufsize = (bufsize + iter) * (iter != 0) + (bufsize << 1) * (iter == 0))
     {
-        latency_bench(latbench_size, latbench_count, 0);
-    }
+        //Bigger dst buffer for strcat and strncat operation
+        if (strstr(bench_func[0].description,"cat"))
+        {
+            poolbuf = alloc_four_nonaliased_buffers((void **)&srcbuf, bufsize,
+                                                    (void **)&dstbuf, MAXREPEATS * bufsize,
+                                                    (void **)&tmpbuf, BLOCKSIZE,
+                                                    NULL, 0);
+        }
+        else
+        {
+            poolbuf = alloc_four_nonaliased_buffers((void **)&srcbuf, bufsize,
+                                                    (void **)&dstbuf, bufsize,
+                                                    (void **)&tmpbuf, BLOCKSIZE,
+                                                    NULL, 0);
+        }
+        printf("SIZE: %zu B \n",bufsize);
+        memset(srcbuf, 'c', bufsize);
 
+        //For handling string functions
+        if (strstr(bench_func[0].description, "str") || strstr(bench_func[0].description, "memchr"))
+        {
+            if (strstr(bench_func[0].description, "strspn"))
+            {
+                size_t accept_len = ceil(sqrt(bufsize));
+                generate_uniq_random_string((char*)srcbuf , accept_len);
+                size_t i ;
+                for (i = 0 ; i < (bufsize - NULL_BYTE); i++)
+                {
+                    *((char *)dstbuf + i) = *((char *)srcbuf + rand() % (accept_len));
+                }
+                *((char *)dstbuf + i) = NULL_TERM_CHAR;
+            }
+            else // for rest of the string functions
+            {
+                *((char *)srcbuf + bufsize - NULL_BYTE) = NULL_TERM_CHAR;
+                if (strstr(bench_func[0].description, "cmp") || strstr(bench_func[0].description, "cat") || strstr(bench_func[0].description, "strstr"))
+                {
+                    memcpy(dstbuf, srcbuf, bufsize);
+                    *((char *)srcbuf + bufsize - 2) = NULL_TERM_CHAR;
+                    *((char *)dstbuf + bufsize - NULL_BYTE) = NULL_TERM_CHAR;
+                }
+            }
+        }
+        if (bench_func[0].description == "memcmp")
+        {
+               memcpy(dstbuf, srcbuf, bufsize);
+        }
+        bandwidth_bench(dstbuf, srcbuf, tmpbuf, bufsize, BLOCKSIZE, " ", bench_func);
+        free(poolbuf);
+    }
     return 0;
-}
+}
\ No newline at end of file
--- Makefile
+++ Makefile_patch
@@ -5,7 +5,7 @@
 endif
 
 tinymembench: main.c util.o util.h asm-opt.h version.h asm-opt.o x86-sse2.o arm-neon.o mips-32.o aarch64-asm.o
-	${CC} -O2 ${CFLAGS} -o tinymembench main.c util.o asm-opt.o x86-sse2.o arm-neon.o mips-32.o aarch64-asm.o -lm
+	${CC} -O2 ${CFLAGS} -Wno-int-conversion -o tinymembench main.c util.o asm-opt.o x86-sse2.o arm-neon.o mips-32.o aarch64-asm.o -lm
 
 util.o: util.c util.h
 	${CC} -O2 ${CFLAGS} -c util.c
